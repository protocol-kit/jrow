#!/bin/bash
set -e

# {{ project.name }} Deployment Script
# This script helps deploy {{ project.name }} server in various environments

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEPLOY_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
PROJECT_ROOT="$(cd "$DEPLOY_ROOT/.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${BLUE}[STEP]${NC} $1"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Deploy with Docker
deploy_docker() {
    log_step "Deploying {{ project.name }} with Docker..."
    
    if ! command_exists docker; then
        log_error "Docker is not installed"
        exit 1
    fi
    
    cd "$DEPLOY_ROOT/docker"
    
    log_info "Building Docker image: {{ docker.image_name }}..."
    docker build -t {{ docker.image_name }}:{{ project.version }} -f Dockerfile "$PROJECT_ROOT"
    docker tag {{ docker.image_name }}:{{ project.version }} {{ docker.image_name }}:latest
    
    if ! command_exists docker-compose && ! docker compose version >/dev/null 2>&1; then
        log_warn "docker-compose not found, starting container manually..."
        docker run -d \
            --name {{ project.name }} \
            -p {{ server.port }}:{{ server.port }} \
            {% if docker.registry -%}
            {{ docker.registry }}/{{ docker.image_name }}:latest
            {%- else -%}
            {{ docker.image_name }}:latest
            {%- endif %}
    else
        log_info "Starting containers with docker-compose..."
        if command_exists docker-compose; then
            docker-compose up -d
        else
            docker compose up -d
        fi
    fi
    
    log_info "✅ Docker deployment complete!"
    log_info "Access the server at: ws://localhost:{{ server.port }}"
    log_info ""
    log_info "Useful commands:"
    log_info "  docker logs -f {{ project.name }}         # View logs"
    log_info "  docker stop {{ project.name }}            # Stop server"
    log_info "  docker start {{ project.name }}           # Start server"
}

# Deploy to Kubernetes
deploy_k8s() {
    log_step "Deploying {{ project.name }} to Kubernetes..."
    
    if ! command_exists kubectl; then
        log_error "kubectl is not installed"
        exit 1
    fi
    
    cd "$DEPLOY_ROOT/k8s"
    
    # Check if namespace exists, create if not
    if ! kubectl get namespace {{ kubernetes.namespace }} >/dev/null 2>&1; then
        log_info "Creating namespace: {{ kubernetes.namespace }}"
        kubectl create namespace {{ kubernetes.namespace }}
    fi
    
    log_info "Applying ConfigMap..."
    kubectl apply -f configmap.yaml -n {{ kubernetes.namespace }}
    
    log_info "Applying Deployment..."
    kubectl apply -f deployment.yaml -n {{ kubernetes.namespace }}
    
    log_info "Waiting for deployment to be ready..."
    kubectl wait --for=condition=available --timeout=300s \
        deployment/{{ project.name }} -n {{ kubernetes.namespace }}
    
    log_info "✅ Kubernetes deployment complete!"
    log_info ""
    log_info "Get service endpoint:"
    log_info "  kubectl get service {{ project.name }} -n {{ kubernetes.namespace }}"
    log_info ""
    log_info "View logs:"
    log_info "  kubectl logs -f deployment/{{ project.name }} -n {{ kubernetes.namespace }}"
    log_info ""
    log_info "Scale deployment:"
    log_info "  kubectl scale deployment/{{ project.name }} --replicas=5 -n {{ kubernetes.namespace }}"
}

# Build release binary
build_release() {
    log_step "Building {{ project.name }} release binary..."
    
    cd "$PROJECT_ROOT"
    
    if [ ! -f "Cargo.toml" ]; then
        log_error "Cargo.toml not found. Are you in the project root?"
        exit 1
    fi
    
    log_info "Running cargo build --release..."
    cargo build --release
    
    log_info "✅ Release binary built successfully!"
    log_info "Binary location: $PROJECT_ROOT/target/release/{{ project.name }}"
    log_info ""
    log_info "Run with:"
    log_info "  $PROJECT_ROOT/target/release/{{ project.name }}"
}

# Run locally
run_local() {
    log_step "Running {{ project.name }} locally..."
    
    cd "$PROJECT_ROOT"
    
    if [ ! -f "Cargo.toml" ]; then
        log_error "Cargo.toml not found. Are you in the project root?"
        exit 1
    fi
    
    # Set environment variables
    export SERVER_PORT={{ server.port }}
    export SERVER_BIND={{ server.bind_address }}
    
    if [ -n "$1" ]; then
        log_info "Running with profile: $1"
        cargo run --release --bin {{ project.name }} -- "$1"
    else
        log_info "Running {{ project.name }} server..."
        log_info "Listening on: {{ server.bind_address }}:{{ server.port }}"
        cargo run --release --bin {{ project.name }}
    fi
}

# Push Docker image
push_docker() {
    {% if docker.registry -%}
    log_step "Pushing Docker image to {{ docker.registry }}..."
    
    if ! command_exists docker; then
        log_error "Docker is not installed"
        exit 1
    fi
    
    local FULL_IMAGE="{{ docker.registry }}/{{ docker.image_name }}"
    
    log_info "Tagging image..."
    docker tag {{ docker.image_name }}:{{ project.version }} "$FULL_IMAGE:{{ project.version }}"
    docker tag {{ docker.image_name }}:{{ project.version }} "$FULL_IMAGE:latest"
    
    log_info "Pushing {{ project.version }}..."
    docker push "$FULL_IMAGE:{{ project.version }}"
    
    log_info "Pushing latest..."
    docker push "$FULL_IMAGE:latest"
    
    log_info "✅ Image pushed successfully!"
    log_info "Pull with: docker pull $FULL_IMAGE:{{ project.version }}"
    {%- else -%}
    log_error "No Docker registry configured in jrow-template.toml"
    log_info "Add 'registry = \"docker.io/username\"' to [docker] section"
    exit 1
    {%- endif %}
}

# Status check
status() {
    log_step "Checking {{ project.name }} status..."
    
    if [ "$1" = "docker" ]; then
        log_info "Docker containers:"
        {% raw %}docker ps --filter "name={{ project.name }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"{% endraw %}
        
        if docker ps --filter "name={{ project.name }}" --quiet | grep -q .; then
            log_info "✅ Docker container is running"
        else
            log_warn "⚠️  Docker container is not running"
        fi
    elif [ "$1" = "k8s" ]; then
        log_info "Kubernetes resources:"
        kubectl get all -n {{ kubernetes.namespace }} -l app={{ project.name }}
        
        log_info ""
        log_info "Pod status:"
        kubectl get pods -n {{ kubernetes.namespace }} -l app={{ project.name }}
    else
        log_info "Checking all deployments..."
        
        # Check Docker
        if docker ps --filter "name={{ project.name }}" --quiet | grep -q .; then
            log_info "✅ Docker: Running"
        else
            log_info "⚠️  Docker: Not running"
        fi
        
        # Check Kubernetes
        if command_exists kubectl && kubectl get deployment {{ project.name }} -n {{ kubernetes.namespace }} >/dev/null 2>&1; then
            log_info "✅ Kubernetes: Deployed"
        else
            log_info "⚠️  Kubernetes: Not deployed"
        fi
    fi
}

# Clean up
cleanup() {
    log_step "Cleaning up {{ project.name }} deployment..."
    
    if [ "$1" = "docker" ]; then
        cd "$DEPLOY_ROOT/docker"
        
        log_info "Stopping containers..."
        if command_exists docker-compose; then
            docker-compose down
        elif docker compose version >/dev/null 2>&1; then
            docker compose down
        else
            docker stop {{ project.name }} 2>/dev/null || true
            docker rm {{ project.name }} 2>/dev/null || true
        fi
        
        log_info "✅ Docker containers stopped and removed"
        
        # Optionally remove images
        read -p "Remove Docker images? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            docker rmi {{ docker.image_name }}:{{ project.version }} 2>/dev/null || true
            docker rmi {{ docker.image_name }}:latest 2>/dev/null || true
            log_info "Docker images removed"
        fi
        
    elif [ "$1" = "k8s" ]; then
        cd "$DEPLOY_ROOT/k8s"
        
        log_info "Deleting Kubernetes resources..."
        kubectl delete -f deployment.yaml -n {{ kubernetes.namespace }} 2>/dev/null || true
        kubectl delete -f configmap.yaml -n {{ kubernetes.namespace }} 2>/dev/null || true
        
        log_info "✅ Kubernetes resources deleted"
        
        # Optionally delete namespace
        read -p "Delete namespace {{ kubernetes.namespace }}? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            kubectl delete namespace {{ kubernetes.namespace }}
            log_info "Namespace deleted"
        fi
    else
        log_error "Please specify 'docker' or 'k8s'"
        exit 1
    fi
}

# Show usage
usage() {
    cat << EOF
{{ project.name }} Deployment Script
Version: {{ project.version }}

Usage: $0 <command> [options]

Commands:
    docker              Deploy using Docker Compose
    k8s                 Deploy to Kubernetes
    build               Build release binary
    run [profile]       Run locally (optionally specify profile)
    push                Push Docker image to registry
    status [docker|k8s] Check deployment status
    cleanup <docker|k8s> Clean up deployment
    help                Show this help message

Examples:
    $0 docker           # Deploy with Docker
    $0 k8s              # Deploy to Kubernetes
    $0 build            # Build release binary
    $0 run              # Run server locally
    $0 push             # Push Docker image
    $0 status docker    # Check Docker status
    $0 cleanup docker   # Stop Docker containers

Environment Variables:
    SERVER_PORT={{ server.port }}
    SERVER_BIND={{ server.bind_address }}

Configuration:
    Deployment configs are in: $DEPLOY_ROOT
    Project root: $PROJECT_ROOT

EOF
}

# Main
main() {
    if [ $# -eq 0 ]; then
        usage
        exit 1
    fi
    
    case "$1" in
        docker)
            deploy_docker
            ;;
        k8s)
            deploy_k8s
            ;;
        build)
            build_release
            ;;
        run)
            run_local "$2"
            ;;
        push)
            push_docker
            ;;
        status)
            status "$2"
            ;;
        cleanup)
            cleanup "$2"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            log_error "Unknown command: $1"
            usage
            exit 1
            ;;
    esac
}

main "$@"

